using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace Hallmanac.CryptoHelpers
{
    public class PasswordHashingSvc
    {
        private const int MinIterationRange = 8000;
        private const int MaxIterationRange = 15000;
        private const int MinSaltSize = 64;
        private const int MaxSaltSize = 96;
        private const int AppHashIterations = 6000;

        private readonly string _globalApplicationSalt;

        /// <summary>
        /// Creates a new instance of the PasswordEncryptionSvc. If the application has a global application salt, then pass 
        /// that into this constructor otherwise the hashing will not match up.
        /// </summary>
        /// <param name="globalApplicationSalt">The global application Salt is used to do an initial hash of the password
        /// and then do a normal salt and hash of the password. The global app salt is kept secret inside Azure Key Vault</param>
        public PasswordHashingSvc(string globalApplicationSalt = null)
        {
            _globalApplicationSalt = globalApplicationSalt;
        }


        /// <summary>
        ///     Generates a random byte array key based on the byte length given and returns it as a hexadecimal string.
        /// </summary>
        /// <param name="byteLength">Length of Byte array used in the random generator</param>
        /// <returns>Hexadecimal text representation of the randomly generated bytes.</returns>
        public string GenerateHexKeyFromByteLength(int byteLength)
        {
            var key = new byte[byteLength];
            GenerateRandomBytes(key);
            return key.BytesToHexString();
        }


        //public FunqResult<PasswordHashingData> HashPassword(string givenPassword)
        //{
        //    if (string.IsNullOrWhiteSpace(givenPassword))
        //    {
        //        return FunqFactory.ResultFail("The given password was null or empty", (PasswordHashingData)null);
        //    }
        //
        //    var hashData = new PasswordHashingData();
        //    var rand = new Random();
        //
        //    // Set the hash data
        //    hashData.NumberOfIterations = rand.Next(MinIterationRange, MaxIterationRange);
        //    hashData.SaltSize = rand.Next(MinSaltSize, MaxSaltSize);
        //    var saltByteArray = PWDTK.GetRandomSalt(hashData.SaltSize);
        //    hashData.Salt = PWDTK.HashBytesToHexString(saltByteArray);
        //
        //    // Run initial hash at an application level
        //    var appHashedPassword = GetAppLevelPasswordHash(givenPassword);
        //
        //    // Take the output of the inital hashing and run it through proper hashing with key stretching
        //    var finalPasswordBytes = PWDTK.PasswordToHash(saltByteArray, appHashedPassword, hashData.NumberOfIterations);
        //    hashData.HashedPassword = PWDTK.HashBytesToHexString(finalPasswordBytes);
        //    return FunqFactory.ResultOk(hashData);
        //}
        //
        //
        public string GetAppLevelPasswordHash(string givenPassword)
        {
            if (string.IsNullOrWhiteSpace(givenPassword))
            {
                return givenPassword;
            }
        
            if (string.IsNullOrWhiteSpace(_globalApplicationSalt))
            {
                var hash512Password = ComputeSha512ToHexString(givenPassword);
                return hash512Password;
            }
            var appSaltByteArray = _globalApplicationSalt.ToHexBytes();
            var appHashedPasswordBytes = PWDTK.PasswordToHash(appSaltByteArray, givenPassword, AppHashIterations);
            var appHashedPassword = PWDTK.HashBytesToHexString(appHashedPasswordBytes);
            return appHashedPassword;
        }





        //public FunqResult ComparePasswords(string givenPassword, PasswordHashingData hashData)
        //{
        //    if (string.IsNullOrWhiteSpace(givenPassword) || string.IsNullOrWhiteSpace(hashData?.HashedPassword) || string.IsNullOrWhiteSpace(hashData.Salt))
        //    {
        //        return FunqFactory.ResultFail("The given data to compare passwords was invalid.", false);
        //    }
        //
        //    var saltByteArray = PWDTK.ToHexBytes(hashData.Salt);
        //
        //    // Run initial hash at an application level
        //    var appHashedPassword = GetAppLevelPasswordHash(givenPassword);
        //
        //    // Take the output of the inital hashing and run it through proper hashing with key stretching
        //    var finalPasswordBytes = PWDTK.PasswordToHash(saltByteArray, appHashedPassword, hashData.NumberOfIterations);
        //    var hashedComparePassword = PWDTK.HashBytesToHexString(finalPasswordBytes);
        //    return hashedComparePassword == hashData.HashedPassword
        //        ? FunqFactory.ResultOk()
        //        : FunqFactory.ResultFail("Passwords did not match");
        //}


        /// <summary>
        ///     Generates random, non-zero bytes using the RNGCryptoServiceProvider
        /// </summary>
        /// <param name="buffer">Length of random bytes to be generated.</param>
        public void GenerateRandomBytes(byte[] buffer)
        {
            if (buffer == null)
                return;
            var rng = RandomNumberGenerator.Create();
            rng.GetBytes(buffer);
            //rng.GetNonZeroBytes(buffer);
        }
        
        ///// <summary>
        /////     Computes a hash based on the HMACSHA512 algorithm using the given key.
        ///// </summary>
        public string ComputeSha512ToHexString(string textToHash)
        {
            if (string.IsNullOrEmpty(textToHash))
                return null;
            var sha512Cng = SHA512.Create();
            var hashBytes = sha512Cng.ComputeHash(Encoding.UTF8.GetBytes(textToHash));
            var hashToHexString = hashBytes.BytesToHexString();
            return hashToHexString;
        }
    }
}
